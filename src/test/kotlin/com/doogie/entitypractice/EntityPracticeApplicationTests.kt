package com.doogie.entitypractice

import com.doogie.entitypractice.model.Account
import com.doogie.entitypractice.model.AccountSummary
import com.doogie.entitypractice.model.AccountTransaction
import com.doogie.entitypractice.model.Book
import com.doogie.entitypractice.model.Client
import com.doogie.entitypractice.model.Identifiable
import com.doogie.entitypractice.model.Library
import com.doogie.entitypractice.model.ProxiedBook
import org.hibernate.SessionFactory
import org.hibernate.testing.transaction.TransactionUtil.doInHibernate
import org.hibernate.testing.transaction.TransactionUtil.doInJPA
import org.junit.Assert.assertEquals
import org.junit.Assert.assertFalse
import org.junit.Assert.assertTrue
import org.junit.Test
import org.junit.runner.RunWith
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.test.context.junit4.SpringRunner
import javax.persistence.EntityManagerFactory


@RunWith(SpringRunner::class)
@SpringBootTest
class EntityPracticeApplicationTests {
    @Autowired
    private lateinit var entityManagerFactory: EntityManagerFactory

    @Test
    fun contextLoads() {
    }

    @Test
    fun sessionScopedIdentity() {
        doInJPA({ entityManagerFactory }) {
            val library = Library()
            it.persist(library)
            it.flush()

            val library1 = it.find(Library::class.java, 1L)
            val book1 = it.find(Book::class.java, 1L)
            val book2 = it.find(Book::class.java, 1L)

            library1.books.apply {
                add(book1)
                add(book2)
            }

            assertEquals(1, library1.books.size)
        }
    }

    @Test
    fun mixedSessions() {
        val book1 = doInJPA<Book>({ this.entityManagerFactory }) { entityManager ->
            entityManager.find(Book::class.java, 1L)
        }
        val book2 = doInJPA<Book>({ this.entityManagerFactory }) { entityManager ->
            entityManager.find(Book::class.java, 1L)
        }
        assertFalse(book1 === book2)

        doInJPA({ entityManagerFactory }) {
            val books = HashSet<Book>()
            books.add(book1)
            books.add(book2)
            assertEquals(2, books.size)
        }
    }

    @Test
    fun transientEntity() {
        doInJPA({ this.entityManagerFactory }) {
            val library = it.find(Library::class.java, 1L) ?: Library()

            val book1 = Book()
            book1.id = 100L
            book1.title = "High-Performance Java Persistence"

            val book2 = Book()
            book2.id = 101L
            book2.title = "Java Persistence with Hibernate"

            library.books.apply {
                add(book1)
                add(book2)
            }

            assertEquals(2, library.books.size)
        }
    }

    @Test
    fun autoGeneratedIdentifiers() {
        val book1 = Book()
        book1.title = "High-Performance Java Persistence"
        val book2 = Book()
        book2.title = "Java Persistence with Hibernate"

        val library = doInJPA<Library>({ this.entityManagerFactory }) {
            val library = it.find(Library::class.java, 1L) ?: Library()
            library.books.apply {
                add(book1)
                add(book2)
            }
            it.persist(library)

            library
        }

        assertFalse(library.books.contains(book1))
        assertFalse(library.books.contains(book2))

    }

    @Test
    fun forcingFlushBeforeAdd() {
        val book1 = Book()
        book1.title = "High-Performance Java Persistence"
        val book2 = Book()
        book2.title = "Java Persistence with Hibernate"

        val library = doInJPA<Library>({ this.entityManagerFactory }) {
            val library = it.find(Library::class.java, 1L) ?: Library()
            it.persist(book1)
            it.persist(book2)

            library.books.apply {
                add(book1)
                add(book2)
            }
            it.persist(library)

            library
        }

        assertTrue(library.books.contains(book1))
        assertTrue(library.books.contains(book2))

    }

    @Test
    fun findSubSelectEntity() {
        doInJPA({ this.entityManagerFactory }) { entityManager ->
            val client = Client().apply {
                id = 1L
                firstName = "John"
                lastName = "Doe"
            }
            entityManager.persist(client)

            val account = Account()
            account.id = 1L
            account.client = client
            account.description = "Checking account"
            entityManager.persist(account)

            val transaction = AccountTransaction()
            transaction.account = account
            transaction.description = "Salary"
            transaction.cents = 100 * 7000
            entityManager.persist(transaction)

            val summary = entityManager
                .createQuery(
                    """
                    select s
                    from AccountSummary s
                    where s.id = :id
                    """,
                    AccountSummary::class.java
                )
                .setParameter("id", account.id)
                .singleResult

            assertEquals("John Doe", summary.clientName)
            assertEquals(100 * 7000, summary.balance)
        }

        doInJPA({ this.entityManagerFactory }) { entityManager ->
            val summary = entityManager.find(AccountSummary::class.java, 1L)
            assertEquals("John Doe", summary.clientName)
            assertEquals(100 * 7000, summary.balance)

            val transaction = AccountTransaction()
            transaction.account = entityManager.getReference(Account::class.java, 1L)
            transaction.description = "Shopping"
            transaction.cents = -100 * 2200
            entityManager.persist(transaction)
            entityManager.flush()

            entityManager.refresh(summary)
            assertEquals(100 * 4800, summary.balance)
        }
    }

    @Test
    fun customProxy() {
        doInHibernate({ this.entityManagerFactory.unwrap(SessionFactory::class.java) }) { session ->
            val book = ProxiedBook().apply {
                id = 1L
                title = "High-Performance Java Persistence"
                author = "Vlad Mihalcea"
            }
            session.persist(book)
            session.flush()
        }

        doInHibernate({ this.entityManagerFactory.unwrap(SessionFactory::class.java) }) { session ->
//            val book = session.getReference(ProxiedBook::class.java, 1L)
            val book = session.getReference(Identifiable::class.java, 1L)

            assertTrue(
                "Loaded entity is not an instance of the proxy interface",
                book is Identifiable
            )

            assertFalse(
                "Proxy class was not created",
                book is ProxiedBook
            )
        }
    }
}
